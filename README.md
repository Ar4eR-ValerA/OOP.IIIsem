# is-oop-y24/Ar4eR-ValerA

[![wakatime](https://wakatime.com/badge/user/6f9f48c5-e4ed-4eb0-b0b7-caf743286d27.svg)](https://wakatime.com/@6f9f48c5-e4ed-4eb0-b0b7-caf743286d27)
# [Лабораторная 0. Isu](Isu)

**Цель:** ознакомиться с языком C#, базовыми механизмами ООП. В шаблонном репозитории описаны базовые сущности, требуется реализовать недостающие методы и написать тесты, которые бы проверили корректность работы.

**Предметная область. С**туденты, группы, переводы (хоть где-то), поиск. Группа имеет название (соответсвует шаблону M3XYY, где X - номер курса, а YY - номер группы). Студент может находиться только в одной группе. Система должна поддерживать механизм перевода между группами, добавления в группу и удаление из группы.

Требуется реализовать предоставленный в шаблоне интерфейс:

```csharp
public interface IIsuService
{
    Group AddGroup(GroupName name);
    Student AddStudent(Group group, string name);

    Student GetStudent(int id);
    Student FindStudent(string name);
    List<Student> FindStudents(GroupName groupName);
    List<Student> FindStudents(CourseNumber courseNumber);

    Group FindGroup(GroupName groupName);
    List<Group> FindGroups(CourseNumber courseNumber);

    void ChangeStudentGroup(Student student, Group newGroup);
}
```

И протестировать написанный код:

```csharp
[Test]
public void AddStudentToGroup_StudentHasGroupAndGroupContainsStudent()
{
}

[Test]
public void ReachMaxStudentPerGroup_ThrowException()
{
}

[Test]
public void CreateGroupWithInvalidName_ThrowException()
{
}

[Test]
public void TransferStudentToAnotherGroup_GroupChanged()
{
}
```

# [Лабораторная 1. Shops](Shops)

**Цель:** продемонстрировать умение выделять сущности и проектировать по ним классы.

**Прикладная область**: магазин, покупатель, доставка, пополнение и покупка товаров. Магазин имеет уникальный идентификатор, название (не обязательно уникальное) и адрес. В каждом магазине установлена своя цена на товар и есть в наличии некоторое количество единиц товара (какого-то товара может и не быть вовсе). Покупатель может производить покупку. Во время покупки - он передает нужную сумму денег магазину. Поставка товаров представляет собой набор товаров, их цен и количества, которые должны быть добавлены в магазин.

Тест кейсы:

1. Поставка товаров в магазин. Создаётся магазин, добавляются в систему товары, происходит поставка товаров в магазин. После добавления товары можно купить.
2. Установка и изменение цен на какой-то товар в магазине.
3. Поиск магазина, в котором партию товаров можно купить максимально дешево. Обработать ситуации, когда товара может быть недостаточно или товаров может небыть нигде.
4. Покупка партии товаров в магазине (набор пар товар + количество). Нужно убедиться, что товаров хватает, что у пользователя достаточно денег. После покупки должны передаваться деньги, а количество товаров измениться.

NB:

- Можно не поддерживать разные цены для одного магазина. Как вариант, можно брать старую цену, если магазин уже содержит этот товар. Иначе брать цену указанную в поставке.
- Пример ожидаемого формата тестов представлен ниже. **Используемые в тестах API магазина/менеджера/etc не являются интерфейсом для реализации в данной лабораторной. Не нужно ему следовать 1 в 1, это просто пример.**

```csharp
public void SomeTest(moneyBefore, productPrice, productCount, productToBuyCount)
{
	var person = new Person("name", moneyBefore);
	var shopManager = new ShopManager();
	var shop = shopManager.Create("shop name", ...);
	var product = shopManager.RegisterProduct("product name");
	
	shop.AddProducts( ... );
	shop.Buy(person, ...);
	
	Assert.AreEquals(moneyBefore - productPrice  * productToBuyCount, person.Money);
	Assert.AreEquals(productCount - productToBuyCount , shop.GetProductInfo(product).Count);
}
```

# [Лабораторная 2. ISUExtra (<3 ОГНП)](IsuExtra)

**Цель:**  научиться выделять зоны ответственности разных сущностей и проектировать связи между ними.

**Предметнвая область:** Реализация системы записи студентов на ОГНП.

Курс ОГНП - дополнительные занятия, которые могут изучать студенты. Курс реализует определенный мегафакультет. Курс изучается в несколько потоков с ограниченным количеством мест. У каждого потока есть свое расписание - список пар, которые проводятся в течение недели. Пара - описание временного интервала в который группа занимается. Пара должна быть ассоциирована с группой, временем, преподавателем и аудиторией.

Студенты могут записываться на два разных курса ОГНП. Студент не может записаться на ОГНП, которое представляет мегафакультет его учебной группы. Учебная группы принадлежат определенному мегафакультету, который определятся из названия группы. Каждый учебная группа имеет список пар. При записи студента должна быть проверка на то, что пары его учебной группы не пересекаются с парами потока ОГНП.

Требуется реализовать функционал:

- Добавление нового ОГНП
- Запись студента на опредленный ОГНП
- Возможность снять запись
- Получение потоков по курсу
- Получение списка студентов в определенной группе ОГНП
- Получение списка не записавшихся на курсы студентов по группе

# [Лабораторная 3. Backups](Backups)
**[TCP Backups Client](Backups.Client)**

**[TCP Backups Server](Backups.Server)**

**Цель:** применить на практике принципы из SOLID, GRASP.

## **Предметная** область

**Бекап (Backup)** — в общем случае, это резервная копия каких-то данных, которая делается для того, чтобы в дальнейшем можно было восстановить эти данные, то есть откатиться до того момента, когда она была создана. В контексте данной системы, бекапом обозначим связанную цепочку созданных точек.

**Точка восстановления (Restore point)** — резервная копия объектов, созданная в определенный момент. Описать можно датой создания и список резервных копий объектов, которые бекапились в момент создания точки.

**Бекапная джоба (Backup job)** - сущность, которая содержит информацию о конфигурации создаваемых бекапов (список файлов, которые нужно бекапить, способ хранения и прочее) и о уже созданных точках данного бекапа. Также отвечает за создание новых точек восстановления.

**Объект джобы (Job object)** - объекты, которые добавлены с бекапную джобу, для которых нужно создавать копии при процессинге джобы.

**Сторадж (Storage)** - файл, в котором хранится резервная копия объекта джобы, который был создан в конкретной точке.

**Репозиторий (Repository)** - абстракция над способом хранения бекапов. В рамках самого простого кейса, репозиторием будет некоторая директория на локальной файловой системе, где будут лежать стораджи.

## Пример логики работы

Выполняем такие действия:

- Создаём джобу, добавляем три объекта FileA FileB FileC
- Запускаем джобу, получаем рестор поинт в котором есть стораджи FileA_1 FileB_1 FileC_1
- Повторяем, получаем стораджи *_2
- Убираем из бекапной джобы FileC, запускаем джобу, получаем третий рестор поинт у которого есть два стораджа - FileA_3 FileB_3

## Создание резервных копий

Под созданием резервной копии файла подразумевается создание копии файла в другом месте. Система должна поддерживать расширяемость в алгоритмах создания резервных копий. Требуется реализовать два алгоритма:

1. Алгоритм раздельного хранения (Split storages) — для каждого объекта, который добавлен в джобу, создается копия - zip файл, в котором лежит объект.
2. Алгоритм общего хранения (Single storage) —  все указанные в бекапе объекты сохраняются в один архив.

## Хранение копий

В лабораторной работе подразуемвается, что резервные копии будут создаваться локально на файловой системе. Но логика выполнения должна абстрагироваться от этого, должна быть введена абстракция - репозиторий (см. принцип DIP из SOLID). И, например, в тестах стоит реализовать хранение в памяти, иначе тесты будут создавать много мусора, будут требовать дополнительной конфигурации, а также могут начать внезапно падать. Ожидаемая структура:

- Корневая директория
    - Директории джоб, которые лежат в корневой директории
        - Файлы резервных копий, которые лежат в директории джобы

## Создание рестор поинтов

За создание новой точки восстановления отвечает джоба. При создании джобы указывается ее название, способ хранения. Джоба может быть отредактирована за счет добавления или удаления. Результатом работы алгоритма является создание новой точки восстановления. Точка восстановления хранит о себе информацию о том, какие объекты были в ней забекаплены.

## Тест кейсы

1. Тест-1
    1. Cоздаю бекапную джобу
    2. Указываю Split storages
    3. Добавляю в джобу два файла
    4. Запускаю создание точки
    5. Удаляю один из файлов
    6. Запускаю создание
    7. Проверяю, что создано две точки и три стораджа
2. Тест-2, который лучше оформлять не тестом т.к. посмотреть нормально можно только на настоящей файловой системе
    1. Cоздаю бекапную джобу, указываю путь директории для хранения бекапов
    2. Указываю Single storage
    3. Добавляю в джобу два файла
    4. Запускаю создание точки
    5. Проверяю, что созданы директории и файлы